% 
% (C) 2009 Muthiah Annamalai <muthuspost@gmail.com>
%     Nonlinear Optics & Nanophotonics Lab, UT-Arlington.
%            
% This code may be used or distributed under terms of MIT License.
% This file is part of the PSA-2D-Mode-Structure-Solver project.
% 
%            
% 10/27/09 : %            
%            DOPA LG mode solver based on closed-form expression
%            for a LG00 pump. The Kumar-Vasilyev conventions are
%            used for the field dependence on +z, and frequency,
%            while the waist is located at 1/e intensity on transverse
%            plane.
%            
%            Convert to using quadratures of the modes.
%            
%            Calculate the Green's functions.
%            
%            Pump power is critical value in region of Po = 1e5-1e6.
%            
% 10/29/09 : Remove loop invariants outside the ODE stepper.
%            The transfer matrix evolution is independent of initial
%            conditions which allows us to solve all 2*Mx*My initial conditions
%            at once for obtaining the Greens functions. Fast solver gives
%            Greens function itself in a time of 14.65s for Mx,y=7!!.
%            
%
% 11/04/09 : Modify PSA parameters for NU-parameters:
%            1560nm signal, 780nm pump, 1kw Pump, power, and 20mm
%            crystal with 100x100micron^2 spot size. Prof. V says earlier gain
%            proportional to pump power, and crystal length was quite high
%            which makes the calculations accumulate error, and give 
%            unreasonable squeezing. Also gain must be capped physically
%            realizable to about 30dB or about 1-1000, factor.
%            Reducing pump power, eliminates using RK-45 and Predictor-Corrector
%            methods for the solutions, as relative convergence of step size
%            is eliminated. Eigenvalue spectrum has 1/lambda, lambda dependence
%            between squeezed and anti-squeezed modes with excellent agreement.
% 
% 11/09/09 : Add correct form of phase mismatch factor in evolution.
%            which is independent of 'dz', and just a function of 'z'.
% 
% 11/13/09 : Completely redo the indexing notations. Fix more index
%            notations while calculating DPR, and DLN.
%            This brings me closer to Mathematica output, and Mathematica
%            output closer to this one. Convergence.
% 
% 11/18/09 : Convert to Matlab compatible scripts.
% 
% 12/02/09 : Use sparse matrices at most places. Remove 50% memory hit.
%            Generally optimize for maximum memory lean-ness.
%            Clear variables beyond their usage points.
%            But dilemma is to see if adding sparse-ness increases
%            memory reach or does it steepen the calculation times?
%            Replace extraneous variables with minimum set.
%	     Remove superfluous QDsn = 0*QDsn type variable reset in loops.
% 	     Remove PLRN
% 12/07/09 : Use complex number matrix ops which are memory efficient.
%            Factor out the odd & even matrices on Cz for speed in matrix
%            products Cz*QDs as there are 50% zeros in this.
%            Use chequered-block matrices.
%            16x16 mode solves in about 104s = 1min 44s! Compare to previous solver
%            at 196s = 3min 16s. And then factor in the 1/2 memory
%            reduction.
%
%            Inline the blockset/get scripts.
%            Actually another level of abstraction is possible,
%            by taking alternative rows & columns of the QDse
%            and the QDso. Two level decomposition first by My x My blocks
%            then by odd-even rows gives the optimal performance of the solver.
%            We solve 16x16 mode case in 51s!
% 
% 12/08/09 : Use kronecker products toeplitz and hankel matrix 
%            forms to generate E0x{o,e}, E0y{o,e} respectively.
%            Reorganize to use least memory while downsampling 
%            to calculate C0z{e,o} before the RK-iteration.
%
% 12/10/09 : Factorial2 function fails for arguments above 85 the way
%            it is implemented. So directly compute the Bmm'(z=0)
%            coupling coefficients using gammaln in log_base_e and
%            invert it back. Not memory efficient, but correct nevertheless.
%            
% 
% 12/14/09 : Sparse matrix donot make sense in QDs{o,e}x{o,e} variables.
%            Also speye -> eye, as matrices eventual become full. Only 
%            DLN, DPR variable sparse-ness IS useful even for 50% fill-in.
% 
% 01/27/09 : Parallelize the sections containing the ODE iterations by 
%            spawning & collecting resources.
% 
% 02/18/09 : Mark files saved under data parallelism as generated by MV9_parallel.
%

clear all
close all
more off
tic
%% Number of signal-idler modes.

%% Mx = 16; My = 16;
%% Mx = 4; My = 4;
%Mx = 32; My = 32;
%Mx = 16; My = 16;
%Mx = 6; My = 4;
Mx = 4; My = 6;
Mx = 16; My = 16;	
%Mx = 512; My = 32;
Mx = 256; My = 32;
Mx = 512; My = 32;
Mx = 32; My = 32;

if ( mod(Mx,2) + mod(My,2) ~= 0 )
  error(' Mx, My need to be even simultaneously ')
end

%% using MKS units
c=2.99792458e8; eps0=8.85e-12;

%% NU-experiment parameters
%% Lz : 20mm crystal, signal: 1560nm, pump: 780nm, deff : 8.7e-12, ns,p: 1.78
lambda_s = 1560e-9; lambda_p = lambda_s/2; ks = 2*pi/lambda_s;  kp = ks*2;
Lz =  20e-3; ns = 1.78; np = ns; deff = 8.7e-12; omega_s = ks*c;
dk = 4*pi*(np-ns)/lambda_s;
theta_p = -pi/2;

%% simulation parameters
Lpts = 300; dz = Lz/(Lpts);
i
%% pump parameters: 20kW pump case with 1/e waist size of pump
P0 = 20e3; ap0x = 400e-6; ap0y = 100e-6;

%% Validation check cases from PQE-10, CLEO-10
%% P0 = 3.1e3; ap0x = 100e-6; ap0y = 50e-6;
P0 = 5e3; ap0x = 100e-6; ap0y = 100e-6;

as0x = sqrt(2)*ap0x; as0y = sqrt(2)*ap0y;

%% Rayleigh length for X, Y modes
Zrx = 2*pi*np*ap0x^2/lambda_p; Zry = 2*pi*np*ap0y^2/lambda_p;
Kappa = omega_s*deff/sqrt(2*eps0*ns^2*np*c^3)*sqrt(P0/(pi*ap0x*ap0y));

%% fast Gouy phase calculation 
evenMx = 0.5 + (0:2:2*Mx);
E0xe = kron(hankel(evenMx(1:Mx/2),evenMx(Mx/2:Mx-1)),toeplitz(mod(1:My,2)));
E0xo = kron(2 + hankel(evenMx(1:Mx/2),evenMx(Mx/2:Mx-1)),toeplitz(mod(1:My,2)));
oddMy = (0.5 + (0:(2*My-1))).*mod([1:My*2],2);
E0ye = kron( ones(Mx/2,Mx/2), hankel( oddMy(1:My), oddMy(My:2*My-1)));
E0yo = E0ye;
 
E0xee = E0xe(1:2:end,1:2:end); E0xeo = E0xe(2:2:end,2:2:end);
E0xoe = E0xo(1:2:end,1:2:end); E0xoo = E0xo(2:2:end,2:2:end);

E0yee = E0ye(1:2:end,1:2:end); E0yeo = E0ye(2:2:end,2:2:end);
E0yoe = E0yo(1:2:end,1:2:end); E0yoo = E0yo(2:2:end,2:2:end);

clear E0ye E0yo E0xo E0xe evenMx oddMy

%% 
%% Indexing Conventions for 4D ((p,l),(r,n)) -> 2D (i,j) contraction 
%% notation. In new index conventions, i is row index, and j is col index,
%% which represent how the j-th mode couples to i-th mode.
%% 
%% Row : i == (p,l) mode  p : row index, l : col index
%%       p = mod( i, My ); l = floor( i / My );
%% Col : j == (r,n) mode  transpose of ( r : row index, n : col index )
%%       r = mod( j, My ); n = floor( j / My );
%% keep everything row-vectors
%% 
pP = mod( [ 0:(Mx*My - 1)], My ); lL = floor( [ 0:(Mx*My - 1)] / My );
nN = lL; rR = pP;

LL = repmat( lL, [Mx*My,1] ); NN = LL';
LN = kronsum( lL', nN );
nzLN = sparse(mod(LN,2)==0);
LL = ( LL.*nzLN ); LN = ( LN.*nzLN );
DLN = sparse(real((-1).^((LL-NN)/2)).*exp(gammaln(LN + 1) - ...
    (  gammaln(1+LN/2) + LN*log(2) + 0.5*(log(2)+gammaln( 1 + LL ) + ...
					  gammaln( 1 + NN )))));
DLN(kron(toeplitz(mod(0:Mx-1,2)),ones(My))>0)=0;
[DLNe,DLNo] = blockget(  DLN, Mx, My );
DLNee = DLNe(1:2:end,1:2:end); DLNeo = DLNe(2:2:end,2:2:end);
DLNoe = DLNo(1:2:end,1:2:end); DLNoo = DLNo(2:2:end,2:2:end);
clear NN LL LN nzLN DLN DLNe DLNo

PP = repmat( pP', [1, Mx*My] ); RR = PP';
PR = kronsum( pP', rR );
nzPR = sparse( mod(PR,2)==0);
PP = ( PP.*nzPR ); PR = ( PR.*nzPR );
DPR = sparse(real((-1).^((PP-RR)/2)).*exp(gammaln(PR + 1) - ...
    (  gammaln(1+PR/2) + PR*log(2) + 0.5*(log(2)+gammaln( 1 + PP ) + gammaln( 1 + RR )))));
DPR(kron(ones(Mx),toeplitz(mod([0:(My-1)],2)))>0)=0;
[DPRe,DPRo] = blockget(  DPR, Mx, My );
DPRee = DPRe(1:2:end,1:2:end); DPReo = DPRe(2:2:end,2:2:end);
DPRoe = DPRo(1:2:end,1:2:end); DPRoo = DPRo(2:2:end,2:2:end);
clear RR PP PR nzPR DPR DPRe DPRo
clear pP lL nN rR DLNe DLNo

%% coupling integral is loop constant and we pull it out.
C0zee = Kappa*DPRee.*DLNee;
C0zoe = Kappa*DPRoe.*DLNoe;
C0zeo = Kappa*DPReo.*DLNeo;
C0zoo = Kappa*DPRoo.*DLNoo;

clear DPRoe DPRoo DPRee DPReo
clear DLNoo DLNoe DLNeo DLNee

%% calculate the Greens function
%% Excite the mn mode in both quadratures so that the
%% output contains the real-valued Greens function automatically.
%% equivalent to eye(2*Mx*My)

%% introducing even, odd blocks.
SZ2 = [Mx*My/4,Mx*My/4];

QDsee = [eye(SZ2),1i*eye(SZ2)]; 
QDseo = QDsee; QDsoe = QDsee; QDsoo = QDsee;

%% RK-4 method following Gilbert Strang

probstr = sprintf('MV9_Mx%d_My%d',Mx,My); datestr = strrep(ctime(time),':','-'); 
matfileprefix = sprintf('%s-%s',probstr,datestr);
matfileprefix = strrep(matfileprefix,' ','-');

suffix_list = {'ee','eo','oe','oo'}; 
pid_child = zeros(4,1);
for idx = 1:4
  suffix = suffix_list{idx};
  matfile = sprintf('%s-%s.mat',matfileprefix(1:end-1),suffix);
  save('-mat',matfile,'Mx','My','Lz',sprintf('C0z%s',suffix),'SZ2','Lpts','dz',sprintf('E0x%s',suffix),sprintf('E0y%s',suffix),'Zrx','Zry','theta_p','dk');
  fprintf('Executing Command Line : octave -q MV9_helper.m "%s" "%s"\n',matfile,suffix);
  pid_child(idx) = system(sprintf('octave -q MV9_helper.m "%s" "%s" ',matfile,suffix),'','async');
  matfilename{idx}=matfile;
  fprintf('Spawning child %d\n',pid_child(idx));
end

for idx = 1:4
  waitpid( pid_child(idx), 0 );
  fprintf('Terminated Child %d\n',pid_child(idx));
end


for idx = 1:4
  matfile = matfilename{idx};
  procfile = sprintf('proc-%s',matfile);
  load(procfile);
  ## unlink(matfile);
  ## unlink(procfile);
end

%% complex valued Greens function : QDs(1:Mx*My,:) + 1i*QDs(Mx*My+1:end,:);

%% inline this 
%% QDs = [blockset(QDse(:,1:ceil(Mx/2)*My),QDso(:,1:ceil(Mx/2)*My),Mx,My),blockset(QDse(:,(1+ceil(Mx/2)*My):end),QDso(:,(1+ceil(Mx/2)*My):end),Mx,My)];

QDs = sparse(Mx*My,2*Mx*My); QDse = sparse(Mx*My/2,Mx*My); QDso = QDse;

%% level-2 rec
QDse(1:2:end,1:2:end)=QDsee; QDso(1:2:end,1:2:end)=QDsoe;
QDse(2:2:end,2:2:end)=QDseo; QDso(2:2:end,2:2:end)=QDsoo;
clear QDsee QDseo QDsoe QDsoo

%% level-1 rec
QDs = [blockset(QDse(:,1:ceil(Mx/2)*My),QDso(:,1:ceil(Mx/2)*My),Mx,My),blockset(QDse(:,(1+ceil(Mx/2)*My):end),QDso(:,(1+ceil(Mx/2)*My):end),Mx,My)];
clear QDse QDso

%% calculate the eigenmodes 'v', and squeezing spectrum 'l'.
QDs = [real(QDs); imag(QDs)];
G = QDs*(QDs.') + j*0;
[eigvec,l] = eig( G );
time_lapse = toc
l = diag(l);
flipud(l)

save('-mat',sprintf('MV9par_Eigspectra_Mx%02d_My%02d-P0%g-A0x%g-A0y%g-%s.mat',Mx,My,P0,ap0x/1e-6,ap0y/1e-6,date),'l','time_lapse','eigvec')
save('-mat',sprintf('MV9par_GreensFn_Mx%02d_My%02d-P0%g-A0x%g-A0y%g-%s.mat',Mx,My,P0,ap0x/1e-6,ap0y/1e-6,date),'G')
